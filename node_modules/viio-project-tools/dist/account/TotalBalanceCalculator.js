"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TotalBalanceCalculator = void 0;
const itrm_tools_1 = require("itrm-tools");
const TransactionDefinitions_1 = require("../definitions/TransactionDefinitions");
class TotalBalanceCalculator {
    constructor(url) {
        this.url = url;
    }
    calculate(userId, asset, config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const transactions = yield itrm_tools_1.RequestAxiosCall.get(`${this.url}/transaction?userId=${userId}&asset=${asset}`, config);
            if (((_a = transactions === null || transactions === void 0 ? void 0 : transactions.result) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                let totalBalance = 0;
                for (const transaction of transactions.result)
                    totalBalance += this.calculateBalanceChange(transaction, asset);
                return totalBalance;
            }
            return 0;
        });
    }
    calculateBalanceChange(transaction, asset) {
        switch (transaction.TransactionStatus.status) {
            case TransactionDefinitions_1.TransactionStatus.APPROVED:
            case TransactionDefinitions_1.TransactionStatus.SUBMITTED:
            case TransactionDefinitions_1.TransactionStatus.BLOCKED:
            case TransactionDefinitions_1.TransactionStatus.INSUFFICIENT_FUNDS:
                return transaction.TransactionTypes.type === TransactionDefinitions_1.TransactionType.DEPOSIT ? this.getTotalValue(transaction.toDetails, asset) : 0;
            case TransactionDefinitions_1.TransactionStatus.COMPLETED:
                return this.calculateApprovedOrCompletedBalanceChange(transaction, asset);
            case TransactionDefinitions_1.TransactionStatus.IN_TREASURY:
            case TransactionDefinitions_1.TransactionStatus.REFUND: return this.calculateInTreasuryOrRefundBalanceChange(transaction, asset);
            case TransactionDefinitions_1.TransactionStatus.FAILED:
            default: return 0;
        }
    }
    calculateApprovedOrCompletedBalanceChange(transaction, asset) {
        switch (transaction.TransactionTypes.type) {
            case TransactionDefinitions_1.TransactionType.REFUND:
            case TransactionDefinitions_1.TransactionType.EXTERNAL_DEPOSIT:
            case TransactionDefinitions_1.TransactionType.DEPOSIT: return this.getTotalValue(transaction.toDetails, asset);
            case TransactionDefinitions_1.TransactionType.EXTERNAL_WITHDRAWAL:
            case TransactionDefinitions_1.TransactionType.WITHDRAWAL: return -this.getTotalValue(transaction.fromDetails, asset);
            case TransactionDefinitions_1.TransactionType.TRANSFER: return transaction.fromDetails.details.paymentRole === TransactionDefinitions_1.TransferType.SENDER ? -this.getTotalValue(transaction.toDetails, asset) : (transaction.fromDetails.details.paymentRole === TransactionDefinitions_1.TransferType.RECEIVER ? this.getTotalValue(transaction.toDetails, asset) : 0);
            default: return 0;
        }
    }
    calculateInTreasuryOrRefundBalanceChange(transaction, asset) {
        switch (transaction.TransactionTypes.type) {
            case TransactionDefinitions_1.TransactionType.WITHDRAWAL: return -this.getTotalValue(transaction.fromDetails, asset);
            default: return 0;
        }
    }
    getTotalValue(details, asset) {
        if (details.ticker === asset)
            return parseFloat(details.total);
        return 0;
    }
}
exports.TotalBalanceCalculator = TotalBalanceCalculator;
//# sourceMappingURL=TotalBalanceCalculator.js.map