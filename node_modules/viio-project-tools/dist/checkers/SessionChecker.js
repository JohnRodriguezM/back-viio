"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionChecker = void 0;
const itrm_tools_1 = require("itrm-tools");
class SessionChecker {
    constructor(sessionService) {
        this.sessionService = sessionService;
    }
    getConfig() {
        return {
            check: 'session',
        };
    }
    apply(config, req) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const authHeader = req.headers.authorization;
                if (/Bearer /g.test(authHeader)) {
                    const token = authHeader.replace(/Bearer /g, '');
                    const user = yield itrm_tools_1.RequestAxiosCall.post(`${this.sessionService}/v1/verify`, { jwt: token });
                    return this.buildApproval(user);
                }
                return this.buildInvalidAuthenticationMethodRejection();
            }
            catch (error) {
                return this.buildUnexpectedErrorRejection(error);
            }
        });
    }
    buildInvalidAuthenticationMethodRejection() {
        return {
            approved: false,
            rejection: {
                code: 401,
                payload: {
                    status: "Error",
                    message: 'Invalid authentication method',
                },
            },
        };
    }
    buildApproval(user) {
        return {
            approved: true,
            payload: {
                userId: user.userId,
                role: user.role,
            },
        };
    }
    buildUnexpectedErrorRejection(error) {
        var _a, _b, _c, _d;
        return {
            approved: false,
            rejection: {
                code: (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : 500,
                payload: {
                    status: "Error",
                    data: (_d = (_c = error === null || error === void 0 ? void 0 : error.response) === null || _c === void 0 ? void 0 : _c.data) !== null && _d !== void 0 ? _d : error,
                },
            },
        };
    }
}
exports.SessionChecker = SessionChecker;
//# sourceMappingURL=SessionChecker.js.map